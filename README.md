# Programming-notes
记录了一些”恍然大悟“的时刻

# 【一、关于数组、指针与隐式转换的原理与真相】
最近在完成学校C语言作业中，我遇到了一个疑惑：对于`a[4][4]`这个二维数组而言，`a`的类型究竟是什么？

声明的时候，a的类型应该是`int[4][4]`，但为什么当我们进行`*(a+1)`等类似的运算时，`a`的类型又仿佛变成了`int (*)[4]`呢？抱着这样的疑问，我去咨询了GPT4，希望能获得答案。

问了一些问题后，我发现GPT4的回答突然开始“自相矛盾”了，明明之前说`*a`的类型是`int*`，之后却又说`*a`的类型是`int[4]`？？？？我本以为是GPT4出了问题，想要继续“拷打”一番。但GPT4突然甩出了“**隐式转换**”这个概念——数组与指针之间也有隐式转换？？？？？

于是我去查阅了cppreference.com这个网站，很快，我就找到了真相：
原来在C语言中，存在着从“**数组到指针的隐式转换**”，这也被称之为“数组到指针的退化”。这个隐式转换的含义是：“存在从数组类型的左值和右值到指针类型的右值的隐式转换：它构造一个指向数组首元素的指针。凡在数组出现于不期待数组而期待指针的语境中时，均使用这个转换：”。

那么，`a`的类型应该就是`int[4][4]`，只不过在绝大多数表达式中，`a`的类型被自动转换为了`int (*)[4]`，这才是为什么我们可以进行`*a+1`和`*(a+1)`等类似的操作。

而GPT4也没有真正意义上的自相矛盾，`*a`的类型就是`int[4]`类型，但是在表达式的语境下，`*a`的类型被隐式转换成了`int*`。

别看了，没了（暂时没啥可写的了

参考网站：[数组声明 - cppreference.com](https://zh.cppreference.com/w/cpp/language/array#.E6.95.B0.E7.BB.84.E5.88.B0.E6.8C.87.E9.92.88.E9.80.80.E5.8C.96)
